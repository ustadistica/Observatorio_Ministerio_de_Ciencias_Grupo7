# -*- coding: utf-8 -*-
"""Codigo_Analisis_Univariado.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1JE9mQLoVY4nfxuGcxKPFC5w7AwDLgthQ
"""

# ================== Paquetes ==================
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

# ================== Cargar base ==================
# Asegúrate de subir el archivo "GRAN_TABLA(SIN ID).xlsx" al entorno de Colab antes de correr esto
df = pd.read_excel("/content/GRAN_TABLA(SIN ID).xlsx")

# ================== Vista general ==================
print("Filas:", df.shape[0])
print("Columnas:", df.shape[1])
print("\nNombres de variables:\n", df.columns.tolist())

# Tipos de datos
print("\nTipos de datos:\n", df.dtypes)

# Primeras filas
df.head()

# ================== Separar por tipo ==================
# Numéricas
num_vars = ['NRO_ORDEN_FORM_PR', 'ORDEN_CLAS_PR', 'EDAD_ANOS_PR']

# Temporales (convertimos a numérico)
df['ANO_CONVO'] = pd.to_numeric(df['ANO_CONVO'], errors='coerce')
temp_vars = ['ANO_CONVO']

# Categóricas: todas las demás
cat_vars = [col for col in df.columns if col not in num_vars + temp_vars]

print("Variables numéricas:", num_vars)
print("Variables temporales:", temp_vars)
print("Variables categóricas (total: {})".format(len(cat_vars)))
print(cat_vars[:10], "...")  # mostramos solo las primeras 10

# ================== Estadísticos básicos ==================
num_summary = df[num_vars].describe().T
num_summary['missing_%'] = df[num_vars].isnull().mean() * 100

print("Resumen de variables numéricas:\n")
print(num_summary)

# ================== Histogramas ==================
for col in num_vars:
    plt.figure(figsize=(6,4))
    sns.histplot(df[col], kde=True, color='skyblue')
    plt.title(f"Distribución de {col}")
    plt.xlabel(col)
    plt.ylabel("Frecuencia")
    plt.show()

# ================== Boxplots ==================
for col in num_vars:
    plt.figure(figsize=(5,3))
    sns.boxplot(x=df[col], color='lightgreen')
    plt.title(f"Boxplot de {col}")
    plt.show()

# ================== Frecuencias y proporciones ==================
for col in cat_vars:
    print(f"\n===== {col} =====")
    print(df[col].value_counts(dropna=False).head(10))  # las 10 más comunes
    print("\nPorcentaje de datos faltantes:", df[col].isna().mean() * 100, "%")

# ================== Visualizaciones simples ==================
# Vamos a graficar solo algunas claves para no saturar la salida

cols_viz = ['NME_GENERO_PR', 'NME_GRAN_AREA_PR', 'NME_REGION_RES_PR', 'NME_NIV_FORM_PR', 'NME_CLASIFICACION_PR']

for col in cols_viz:
    plt.figure(figsize=(7,4))
    df[col].value_counts().head(10).plot(kind='bar', color='skyblue')
    plt.title(f"Distribución de {col}")
    plt.ylabel("Frecuencia")
    plt.xlabel(col)
    plt.xticks(rotation=45, ha='right')
    plt.show()

# --- 1) Vuelve a leer SOLO la columna ANO_CONVO desde el Excel ---
# (ajusta la ruta si tu archivo está en otro sitio)
ruta = "/content/GRAN_TABLA(SIN ID).xlsx"
ano_convo_excel = pd.read_excel(ruta, usecols=["ANO_CONVO"])

# Reinyectar en tu df ya cargado
df["ANO_CONVO_ORIG"] = ano_convo_excel["ANO_CONVO"]

# --- 2) Parseo robusto a fecha ---
# Intento A: texto 'dd/mm/aaaa'
s = df["ANO_CONVO_ORIG"].astype(str).str.strip()
s_dt = pd.to_datetime(s, dayfirst=True, errors="coerce")

# Intento B (respaldo): serial de Excel (por si vinieran como números)
s_num = pd.to_numeric(s, errors="coerce")
s_dt2 = pd.to_datetime(s_num, unit="D", origin="1899-12-30", errors="coerce")

# Usar el mejor de los dos intentos
df["ANO_CONVO_FECHA"] = s_dt.where(s_dt.notna(), s_dt2)
df["ANO_CONVO_ANO"] = df["ANO_CONVO_FECHA"].dt.year

# --- 3) Conteo y gráfico ---
conteo_ano = df["ANO_CONVO_ANO"].dropna().value_counts().sort_index()
print("Años detectados:", conteo_ano.index.tolist())
print("\nNúmero de investigadores por convocatoria:")
print(conteo_ano)

plt.figure(figsize=(6,4))
plt.bar(conteo_ano.index.astype(int), conteo_ano.values)
plt.title("Distribución de investigadores por año de convocatoria")
plt.xlabel("Año de convocatoria")
plt.ylabel("Cantidad de investigadores")
plt.tight_layout()
plt.show()